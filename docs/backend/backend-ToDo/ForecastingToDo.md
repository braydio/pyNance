# Forecasting Backend Audit & TODOs

*(Grounded in `frontend/src/views/Forecast.vue` + forecast components)*

---

## 0. Ground Truth: What the frontend ALREADY assumes

From `Forecast.vue`:

```vue
<PageHeader icon="LineChart">
  <template #title>Forecast</template>
  <template #subtitle>Project your financial future</template>
</PageHeader>

<ForecastLayout />
```

This tells us:

* Forecasting is:

  * Global (not per-account UI)
  * Predictive
  * Forward-looking
* `ForecastLayout` must be able to:

  * Load initial forecast
  * Recompute forecast when adjustments change
  * Display multiple derived views of the same forecast

**Backend implication**:
Forecasting is **stateful, recomputable, and scenario-aware**.

---

## 1. REF Docs Audit (what they actually say)

### 00REF_ForecastDev_Checklist.md (intent)

This file establishes:

* Forecasting is **not read-only**
* Users can:

  * Adjust assumptions
  * See impact immediately
* Forecasts must be:

  * Deterministic
  * Explainable
  * Repeatable

**Backend TODO #1**

> Forecast results must be generated by a pure, deterministic function
> (same inputs → same outputs)

---

### 01REF_Architecture_Design.md (core design)

Key ideas (paraphrased but faithful):

* Forecast is composed of **layers**:

  1. Baseline projection
  2. Adjustments
  3. Derived summaries

* Forecast data should be returned as a **single structured object**, not many endpoints

* Frontend should not “calculate”, only **visualize**

**Backend TODO #2**
Create a `ForecastResult` domain object that includes:

```json
{
  "timeline": [...],
  "balances": [...],
  "cashflows": [...],
  "adjustments": [...],
  "summary": {...},
  "metadata": {...}
}
```

---

### 02REF_API_Integration.md (contract expectations)

This is where things get concrete.

Expected behaviors:

* Initial load → default forecast
* User edits → recompute forecast
* No persistence required *initially*

**Backend TODO #3**
Implement **stateless forecast computation**:

```
POST /api/forecast/compute
```

Payload:

```json
{
  "start_date": "2026-01-24",
  "horizon_days": 90,
  "adjustments": [...]
}
```

Response:

```json
ForecastResult
```

---

### 03REF_Development_Planning.md (unfinished ideas)

This doc explicitly calls out:

* Backend is a blocker
* Forecast engine should start “simple but correct”
* Recurring detection can be naive initially

**Backend TODO #4**
Phase forecasting into levels:

* Phase 1: deterministic rules
* Phase 2: recurrence inference
* Phase 3: scenario persistence

---

## 2. Mapping Frontend Components → Backend Responsibilities

Now let’s **tie each UI component to backend requirements**.

---

## ForecastChart.vue → Timeline + balances

### What the component expects

* X-axis: future dates
* Y-axis: projected balances
* Updates when adjustments change

**Backend TODO #5**

Provide a `timeline` array like:

```json
[
  {
    "date": "2026-01-25",
    "balance": 5234.12
  },
  {
    "date": "2026-01-26",
    "balance": 5179.12
  }
]
```

**Implementation detail (finished idea)**
Balance projection algorithm:

```text
balance[t+1] =
  balance[t]
+ sum(expected_inflows[t])
- sum(expected_outflows[t])
+ sum(adjustments[t])
```

No ML. No guessing. Explainable math.

---

## ForecastSummaryPanel.vue → Derived metrics

This component implies:

* Net change
* Ending balance
* Risk signals (runway, depletion)

**Backend TODO #6**

Compute a `summary` block:

```json
{
  "starting_balance": 5400.00,
  "ending_balance": 3200.55,
  "net_change": -2199.45,
  "min_balance": 1100.00,
  "depletion_date": null
}
```

**Finished idea**
Depletion logic:

```python
if balance < 0 for first time:
    depletion_date = date
else:
    depletion_date = null
```

---

## ForecastBreakdown.vue → Explainability

This component *only makes sense* if the backend provides **causal attribution**.

**Backend TODO #7**

Return a breakdown structure:

```json
{
  "income": {
    "payroll": 6000,
    "interest": 25
  },
  "expenses": {
    "rent": 2200,
    "subscriptions": 180,
    "utilities": 140
  },
  "adjustments": {
    "manual_override": -500
  }
}
```

**Finished idea**
Each projected cashflow must carry a `source`:

```json
{
  "date": "2026-02-01",
  "amount": -2200,
  "type": "expense",
  "source": "rent",
  "confidence": "high"
}
```

---

## ForecastAdjustmentsForm.vue → User overrides

This component is explicit:
Users can **change the future**.

**Backend TODO #8**

Define adjustment schema:

```json
{
  "id": "uuid",
  "type": "one_time" | "recurring",
  "amount": -500,
  "start_date": "2026-02-10",
  "frequency": "monthly",
  "label": "Vacation"
}
```

**Finished idea**
Adjustments are applied **after baseline projection**, not baked in.

Why?

* Allows comparison
* Allows toggling
* Enables scenarios later

---

## ForecastComponent.vue → Orchestration

This component assumes:

* One call returns *everything*
* Recompute is cheap
* No partial state

**Backend TODO #9**

Single orchestration function:

```python
def compute_forecast(
    user_id,
    start_date,
    horizon_days,
    adjustments
) -> ForecastResult
```

This function:

1. Loads latest account snapshots
2. Builds baseline cashflow
3. Applies adjustments
4. Computes summaries
5. Returns full result

---

## 3. Core Backend Modules to Create (explicit)

Here is the **exact TODO list** you can drop into GitHub issues.

---

### Module: `backend/forecast/engine.py`

* `compute_forecast(...)`
* `project_balances(...)`
* `apply_adjustments(...)`

---

### Module: `backend/forecast/models.py`

* `ForecastResult`
* `ForecastTimelinePoint`
* `ForecastCashflowItem`
* `ForecastAdjustment`

---

### Module: `backend/api/forecast.py`

Endpoints:

* `POST /api/forecast/compute`
* (future) `POST /api/forecast/scenario/save`

---

### Module: `backend/workers/forecast_refresh.py`

* Recompute cached forecasts when:

  * Transactions refresh
  * Snapshots update

*(optional in Phase 1)*

---

## 4. Results

| Idea                            | Status                                |
| ------------------------------- | ------------------------------------- |
| “Project your financial future” | → deterministic forward balance model |
| “Scenario planning”             | → adjustment overlays                 |
| “Explainable forecast”          | → source-tagged cashflows             |
| “Interactive recompute”         | → stateless POST compute              |
| “Forecast dashboard”            | → already built in frontend           |


* Write Alembic migrations for adjustments/scenarios

